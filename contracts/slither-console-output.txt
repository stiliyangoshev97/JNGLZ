'forge clean' running (wd: /Users/stiliyangoshev/Desktop/Coding/Full Projects/JunkieDotFun/contracts)
'forge config --json' running
'forge build --build-info src/PredictionMarket.sol' running (wd: /Users/stiliyangoshev/Desktop/Coding/Full Projects/JunkieDotFun/contracts)

PredictionMarket._distributeJuryFees(uint256,PredictionMarket.Market,uint256) (src/PredictionMarket.sol#1149-1186) sends eth to arbitrary user
	Dangerous calls:
	- (success,None) = treasury.call{value: voterPool}() (src/PredictionMarket.sol#1161)
PredictionMarket._executeAction(uint256) (src/PredictionMarket.sol#1833-1973) sends eth to arbitrary user
	Dangerous calls:
	- (success,None) = treasury.call{value: surplus}() (src/PredictionMarket.sol#1936)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#functions-that-send-ether-to-arbitrary-destinations

PredictionMarket.claim(uint256) (src/PredictionMarket.sol#1193-1232) performs a multiplication on the result of a division:
	- grossPayout = (winningShares * market.poolBalance) / totalWinningShares (src/PredictionMarket.sol#1211-1212)
	- fee = (grossPayout * resolutionFeeBps) / BPS_DENOMINATOR (src/PredictionMarket.sol#1215)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#divide-before-multiply

Reentrancy in PredictionMarket.buyNo(uint256,uint256) (src/PredictionMarket.sol#641-683):
	External calls:
	- (success,None) = treasury.call{value: platformFee}() (src/PredictionMarket.sol#671)
	State variables written after the call(s):
	- pendingCreatorFees[market.creator] += creatorFee (src/PredictionMarket.sol#677)
	- totalPendingCreatorFees += creatorFee (src/PredictionMarket.sol#678)
Reentrancy in PredictionMarket.buyYes(uint256,uint256) (src/PredictionMarket.sol#594-636):
	External calls:
	- (success,None) = treasury.call{value: platformFee}() (src/PredictionMarket.sol#624)
	State variables written after the call(s):
	- pendingCreatorFees[market.creator] += creatorFee (src/PredictionMarket.sol#630)
	- totalPendingCreatorFees += creatorFee (src/PredictionMarket.sol#631)
Reentrancy in PredictionMarket.sellNo(uint256,uint256,uint256) (src/PredictionMarket.sol#743-793):
	External calls:
	- (success,None) = treasury.call{value: platformFee}() (src/PredictionMarket.sol#778)
	State variables written after the call(s):
	- pendingCreatorFees[market.creator] += creatorFee (src/PredictionMarket.sol#784)
	- totalPendingCreatorFees += creatorFee (src/PredictionMarket.sol#785)
Reentrancy in PredictionMarket.sellYes(uint256,uint256,uint256) (src/PredictionMarket.sol#688-738):
	External calls:
	- (success,None) = treasury.call{value: platformFee}() (src/PredictionMarket.sol#723)
	State variables written after the call(s):
	- pendingCreatorFees[market.creator] += creatorFee (src/PredictionMarket.sol#729)
	- totalPendingCreatorFees += creatorFee (src/PredictionMarket.sol#730)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-2

Reentrancy in PredictionMarket._executeAction(uint256) (src/PredictionMarket.sol#1833-1973):
	External calls:
	- (success,None) = treasury.call{value: surplus}() (src/PredictionMarket.sol#1936)
	Event emitted after the call(s):
	- ActionExecuted(actionId,action.actionType) (src/PredictionMarket.sol#1972)
	- FundsSwept(surplus,totalLocked,contractBalance) (src/PredictionMarket.sol#1939)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-3

PredictionMarket._createMarket(string,string,string,string,uint256,PredictionMarket.HeatLevel) (src/PredictionMarket.sol#542-587) uses timestamp for comparisons
	Dangerous comparisons:
	- expiryTimestamp <= block.timestamp (src/PredictionMarket.sol#553)
PredictionMarket.proposeOutcome(uint256,bool) (src/PredictionMarket.sol#803-847) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp < market.expiryTimestamp + CREATOR_PRIORITY_WINDOW (src/PredictionMarket.sol#820)
PredictionMarket.dispute(uint256) (src/PredictionMarket.sol#854-888) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp > market.proposalTime + DISPUTE_WINDOW (src/PredictionMarket.sol#863)
PredictionMarket.vote(uint256,bool) (src/PredictionMarket.sol#896-928) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp > market.disputeTime + VOTING_WINDOW (src/PredictionMarket.sol#903)
PredictionMarket.finalizeMarket(uint256) (src/PredictionMarket.sol#935-1063) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp <= market.proposalTime + DISPUTE_WINDOW (src/PredictionMarket.sol#943)
	- block.timestamp <= market.disputeTime + VOTING_WINDOW (src/PredictionMarket.sol#1008)
PredictionMarket.emergencyRefund(uint256) (src/PredictionMarket.sol#1238-1269) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp < market.expiryTimestamp + EMERGENCY_REFUND_DELAY (src/PredictionMarket.sol#1244)
PredictionMarket.canEmergencyRefund(uint256) (src/PredictionMarket.sol#1529-1544) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp >= emergencyTime (src/PredictionMarket.sol#1539)
PredictionMarket.confirmAction(uint256) (src/PredictionMarket.sol#1694-1717) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp > action.createdAt + ACTION_EXPIRY (src/PredictionMarket.sol#1698)
PredictionMarket.executeAction(uint256) (src/PredictionMarket.sol#1723-1739) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp > action.createdAt + ACTION_EXPIRY (src/PredictionMarket.sol#1727)
PredictionMarket._getMarketStatus(PredictionMarket.Market) (src/PredictionMarket.sol#1750-1759) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp >= market.expiryTimestamp (src/PredictionMarket.sol#1756)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp

StorageSlot.getAddressSlot(bytes32) (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#66-70) uses assembly
	- INLINE ASM (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#67-69)
StorageSlot.getBooleanSlot(bytes32) (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#75-79) uses assembly
	- INLINE ASM (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#76-78)
StorageSlot.getBytes32Slot(bytes32) (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#84-88) uses assembly
	- INLINE ASM (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#85-87)
StorageSlot.getUint256Slot(bytes32) (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#93-97) uses assembly
	- INLINE ASM (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#94-96)
StorageSlot.getInt256Slot(bytes32) (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#102-106) uses assembly
	- INLINE ASM (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#103-105)
StorageSlot.getStringSlot(bytes32) (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#111-115) uses assembly
	- INLINE ASM (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#112-114)
StorageSlot.getStringSlot(string) (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#120-124) uses assembly
	- INLINE ASM (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#121-123)
StorageSlot.getBytesSlot(bytes32) (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#129-133) uses assembly
	- INLINE ASM (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#130-132)
StorageSlot.getBytesSlot(bytes) (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#138-142) uses assembly
	- INLINE ASM (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#139-141)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#assembly-usage

2 different versions of Solidity are used:
	- Version constraint ^0.8.20 is used by:
		-^0.8.20 (lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol#4)
		-^0.8.20 (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#5)
	- Version constraint 0.8.24 is used by:
		-0.8.24 (src/PredictionMarket.sol#2)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#different-pragma-directives-are-used

PredictionMarket.finalizeMarket(uint256) (src/PredictionMarket.sol#935-1063) has a high cyclomatic complexity (12).
PredictionMarket._executeAction(uint256) (src/PredictionMarket.sol#1833-1973) has a high cyclomatic complexity (43).
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#cyclomatic-complexity

Version constraint ^0.8.20 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html)
	- VerbatimInvalidDeduplication
	- FullInlinerNonExpressionSplitArgumentEvaluationOrder
	- MissingSideEffectsOnSelectorAccess.
It is used by:
	- ^0.8.20 (lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol#4)
	- ^0.8.20 (lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol#5)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-versions-of-solidity

Low level call in PredictionMarket.createMarket(string,string,string,string,uint256,PredictionMarket.HeatLevel) (src/PredictionMarket.sol#441-465):
	- (success,None) = treasury.call{value: msg.value}() (src/PredictionMarket.sol#462)
Low level call in PredictionMarket.createMarketAndBuy(string,string,string,string,uint256,PredictionMarket.HeatLevel,bool,uint256) (src/PredictionMarket.sol#472-540):
	- (success,None) = treasury.call{value: treasuryAmount}() (src/PredictionMarket.sol#528)
Low level call in PredictionMarket.buyYes(uint256,uint256) (src/PredictionMarket.sol#594-636):
	- (success,None) = treasury.call{value: platformFee}() (src/PredictionMarket.sol#624)
Low level call in PredictionMarket.buyNo(uint256,uint256) (src/PredictionMarket.sol#641-683):
	- (success,None) = treasury.call{value: platformFee}() (src/PredictionMarket.sol#671)
Low level call in PredictionMarket.sellYes(uint256,uint256,uint256) (src/PredictionMarket.sol#688-738):
	- (success,None) = treasury.call{value: platformFee}() (src/PredictionMarket.sol#723)
	- (successTransfer,None) = msg.sender.call{value: bnbOut}() (src/PredictionMarket.sol#734)
Low level call in PredictionMarket.sellNo(uint256,uint256,uint256) (src/PredictionMarket.sol#743-793):
	- (success,None) = treasury.call{value: platformFee}() (src/PredictionMarket.sol#778)
	- (successTransfer,None) = msg.sender.call{value: bnbOut}() (src/PredictionMarket.sol#789)
Low level call in PredictionMarket.proposeOutcome(uint256,bool) (src/PredictionMarket.sol#803-847):
	- (success,None) = treasury.call{value: fee}() (src/PredictionMarket.sol#842)
Low level call in PredictionMarket.dispute(uint256) (src/PredictionMarket.sol#854-888):
	- (success,None) = treasury.call{value: fee}() (src/PredictionMarket.sol#883)
Low level call in PredictionMarket._distributeJuryFees(uint256,PredictionMarket.Market,uint256) (src/PredictionMarket.sol#1149-1186):
	- (success,None) = treasury.call{value: voterPool}() (src/PredictionMarket.sol#1161)
Low level call in PredictionMarket.claim(uint256) (src/PredictionMarket.sol#1193-1232):
	- (feeSuccess,None) = treasury.call{value: fee}() (src/PredictionMarket.sol#1223)
	- (success,None) = msg.sender.call{value: payout}() (src/PredictionMarket.sol#1228)
Low level call in PredictionMarket.emergencyRefund(uint256) (src/PredictionMarket.sol#1238-1269):
	- (success,None) = msg.sender.call{value: refund}() (src/PredictionMarket.sol#1265)
Low level call in PredictionMarket.withdrawBond() (src/PredictionMarket.sol#1278-1291):
	- (success,None) = msg.sender.call{value: amount}() (src/PredictionMarket.sol#1287)
Low level call in PredictionMarket.withdrawCreatorFees() (src/PredictionMarket.sol#1298-1315):
	- (success,None) = msg.sender.call{value: amount}() (src/PredictionMarket.sol#1311)
Low level call in PredictionMarket._executeAction(uint256) (src/PredictionMarket.sol#1833-1973):
	- (success,None) = treasury.call{value: surplus}() (src/PredictionMarket.sol#1936)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls
src/PredictionMarket.sol analyzed (3 contracts with 100 detectors), 45 result(s) found
INFO:Slither:slither-output.json exists already, the overwrite is prevented
