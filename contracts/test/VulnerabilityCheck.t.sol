// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import "./helpers/TestHelper.sol";

/**
 * @title VulnerabilityCheckTest
 * @notice Tests to verify and demonstrate potential vulnerabilities in the bonding curve
 */
contract VulnerabilityCheckTest is TestHelper {
    /**
     * @notice Test to check if selling all shares can cause pool underflow
     * @dev This demonstrates the bonding curve math issue where:
     *      - User buys shares at price P1
     *      - Price increases due to the buy
     *      - User tries to sell at higher price P2
     *      - grossBnbOut at P2 > poolBalance (what was deposited at P1)
     */
    function test_PoolUnderflow_LargeBuy() public {
        uint256 marketId = createTestMarket(marketCreator, 7 days);

        // Alice buys a significant amount - 10 BNB
        vm.deal(alice, 20 ether);
        uint256 sharesBought = buyYesFor(alice, marketId, 10 ether, 0);

        console.log("=== Large Buy Scenario ===");
        console.log("Shares bought:", sharesBought);

        // Get pool balance after buy
        (, , , , , uint256 yesSupply, , uint256 poolBalance, , , , ) = market
            .getMarket(marketId);
        console.log("YES Supply:", yesSupply);
        console.log("Pool balance after buy:", poolBalance);

        // Preview selling ALL shares
        uint256 sellPreviewNet = market.previewSell(
            marketId,
            sharesBought,
            true
        );
        // Reverse the fee to get gross
        uint256 sellPreviewGross = (sellPreviewNet * BPS_DENOMINATOR) /
            (BPS_DENOMINATOR - DEFAULT_FEE_BPS);

        console.log("Preview sell (net, after fee):", sellPreviewNet);
        console.log("Preview sell (gross, before fee):", sellPreviewGross);
        console.log("Pool balance:", poolBalance);

        if (sellPreviewGross > poolBalance) {
            console.log("!!! VULNERABILITY DETECTED !!!");
            console.log(
                "Gross BNB out exceeds pool balance by:",
                sellPreviewGross - poolBalance
            );

            // This WILL revert with arithmetic underflow
            vm.prank(alice);
            vm.expectRevert(); // Expect arithmetic underflow
            market.sellYes(marketId, sharesBought, 0);
        } else {
            console.log("OK: Pool has sufficient balance");
            // Should succeed
            uint256 bnbOut = sellYesFor(alice, marketId, sharesBought, 0);
            console.log("Actual BNB received:", bnbOut);
        }
    }

    /**
     * @notice Test with moderate amounts to see threshold
     */
    function test_PoolUnderflow_ModerateBuy() public {
        uint256 marketId = createTestMarket(marketCreator, 7 days);

        // Alice buys 1 BNB worth
        uint256 sharesBought = buyYesFor(alice, marketId, 1 ether, 0);

        console.log("=== Moderate Buy Scenario (1 BNB) ===");
        console.log("Shares bought:", sharesBought);

        (, , , , , , , uint256 poolBalance, , , , ) = market.getMarket(
            marketId
        );
        console.log("Pool balance:", poolBalance);

        uint256 sellPreviewNet = market.previewSell(
            marketId,
            sharesBought,
            true
        );
        uint256 sellPreviewGross = (sellPreviewNet * BPS_DENOMINATOR) /
            (BPS_DENOMINATOR - DEFAULT_FEE_BPS);

        console.log("Gross BNB out:", sellPreviewGross);

        if (sellPreviewGross > poolBalance) {
            console.log("VULNERABLE at 1 BNB");
        } else {
            console.log("OK at 1 BNB - can sell all shares");
            uint256 bnbOut = sellYesFor(alice, marketId, sharesBought, 0);
            assertGt(bnbOut, 0);
        }
    }

    /**
     * @notice Test selling partial positions to find safe threshold
     */
    function test_FindSafeSellingThreshold() public {
        uint256 marketId = createTestMarket(marketCreator, 7 days);

        vm.deal(alice, 20 ether);
        uint256 sharesBought = buyYesFor(alice, marketId, 10 ether, 0);

        (, , , , , , , uint256 poolBalance, , , , ) = market.getMarket(
            marketId
        );

        console.log("=== Finding Safe Threshold ===");
        console.log("Total shares:", sharesBought);
        console.log("Pool balance:", poolBalance);

        // Try different percentages
        uint256[] memory percentages = new uint256[](5);
        percentages[0] = 10;
        percentages[1] = 25;
        percentages[2] = 50;
        percentages[3] = 75;
        percentages[4] = 100;

        for (uint256 i = 0; i < percentages.length; i++) {
            uint256 sharesToSell = (sharesBought * percentages[i]) / 100;
            uint256 sellPreviewNet = market.previewSell(
                marketId,
                sharesToSell,
                true
            );
            uint256 sellPreviewGross = (sellPreviewNet * BPS_DENOMINATOR) /
                (BPS_DENOMINATOR - DEFAULT_FEE_BPS);

            console.log("---");
            console.log("Percentage:", percentages[i]);
            console.log("Shares to sell:", sharesToSell);
            console.log("Gross BNB needed:", sellPreviewGross);

            if (sellPreviewGross > poolBalance) {
                console.log("UNSAFE - would underflow");
            } else {
                console.log("SAFE - pool has enough");
            }
        }
    }

    /**
     * @notice Verify the mathematical relationship
     */
    function test_BondingCurveMathAnalysis() public {
        uint256 marketId = createTestMarket(marketCreator, 7 days);

        console.log("=== Bonding Curve Math Analysis ===");
        console.log("UNIT_PRICE:", UNIT_PRICE);
        console.log("VIRTUAL_LIQUIDITY:", VIRTUAL_LIQUIDITY);

        // Initial prices (50/50)
        uint256 initialYesPrice = market.getYesPrice(marketId);
        uint256 initialNoPrice = market.getNoPrice(marketId);
        console.log("Initial YES price:", initialYesPrice);
        console.log("Initial NO price:", initialNoPrice);
        console.log("Sum:", initialYesPrice + initialNoPrice);

        // Buy YES
        vm.deal(alice, 5 ether);
        uint256 sharesBought = buyYesFor(alice, marketId, 5 ether, 0);

        // New prices
        uint256 newYesPrice = market.getYesPrice(marketId);
        uint256 newNoPrice = market.getNoPrice(marketId);
        console.log("After buy - YES price:", newYesPrice);
        console.log("After buy - NO price:", newNoPrice);
        console.log("Sum:", newYesPrice + newNoPrice);

        // The issue: when you buy, price goes UP
        // When you sell at the higher price, you get MORE BNB than the pool received
        // This is because the bonding curve formula for sell uses CURRENT (post-buy) prices

        console.log("---");
        console.log("Price increase:", newYesPrice - initialYesPrice);
        console.log("This means selling gives MORE than buying cost!");
    }
}
